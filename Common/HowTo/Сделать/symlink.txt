Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-12-15T02:06:59+02:00

====== symlink ======

[ @debian @symlink ]

symlink — сокращение от „symbolic link” — ссылка на хардлинк. 

При редактировании симлинка происходит редактирование оригинального файла, на который ссылается симлинк. 

Но при удалении симлинка оригинальный файл остаётся на диске. См. теорию [[Software:Симлинки и хардлинки]]

И см. [[hardlink]]

Симлинки можно делать на определенные файлы, которые воспринимаются и открываются как файлы (pdf или txt). А ещё можно делать симлинки на файлы, которые работают как команды в консоли. Если нет нужды делать симлинки, которые нужны множеству пользователей, то лучше использовать алиасы в файле ''.bashrc'' — они будут работать по тому же принципу, но всегда проще прочитать файл ''~/.bashrc'' и увидеть/отредактировать список алиасов и местонахождение файлов, на которые они ссылаются. Также это упрощает жизнь при переустановке системы. См. [[Сделать:alias]]

===== Создать симлинк на файл =====

''ln -s /home/mySettings/myScripts/debian/debian_update_and_upgrade.sh ~/.local/bin/debup''

В каталоге ''~/.local/bin/'' появится новый файл с названием “''~debup''”.

Почему “''debup''”? Как захотел, так и назвал. Если бы не прописал ему название, то появился бы файл ''~debian_update_and_upgrade.sh''

Почему он отображается с тильдой? Потому что это не сам файл, а симлинк на файл.

===== Создать симлинк на каталог =====

''ln -s /home/mySettings/myScripts/ ~/test/''

В каталоге ''~/test/'' появится “каталог” ''~myScripts''.

''ln -s /home/mySettings/myScripts/ ~/test/ВсякоФайло''

В каталоге ''~/test/'' появится “каталог” ''~ВсякоФайло''.

Если не указывать место, где должен появиться симлинк, то он появится в текущем каталоге.

===== Проверить симлинк =====

==== через ls ====

И параметр ''-l'' (long format)

''ls -l debup''

Ожидаем ответ такого вида:

''lrwxrwxrwx 1 [UserName> [UserGroup> 62 дек 15 03:21 debup -> /home/mySettings/myScripts/debian/debian_update_and_upgrade.sh''

Читается так: 
	* права доступа
	* количество симлинков на исходный файл
	* автор
	* группа автора
	* размер файла
	* время создания
	* имя (симлинка)
	* путь к файлу, на который этот симлинк указывает

Можно узнать сразу и если файл — симлинк, и если да, то узнать inode, на который он указывает

''ls -li debup''

Можно получить информацию сразу о нескольких файлах

''ls -li debup dupbup''

И если в ответе видно, что оба файла указывают на один и тот же inode, то перед нами хардлинки.

==== через file ====


$ file tyre
tyre: symbolic link to tubor

Indeed, tyre is a symlink. However, if a file isn’t a symbolic link, file prints information about the file type and its contents.

To illustrate, let’s see the output when we run the file command on a file that’s not a symbolic link:

$ file thesis1
thesis1: ASCII text

In this case, we get the type ASCII text instead.

Now, let’s turn to a common command that works with links.
6. Using the readlink Command

Let’s say we want to determine the target of a symbolic link. To do so, we can use the readlink command. The readlink command displays the target file that a soft link points to.

In general, to use the readlink command, we type in the command followed by the file name as argument:

$ readlink symbolic_link_name
some_file

For example, let’s check the target file for the symlink, tyre:

$ readlink tyre
tubor

In this case, the readlink command shows the target file or directory that the soft link points to.

However, the command returns nothing if the file doesn’t exist or isn’t a symlink. In this case, we can employ the -v flag to see the exact error message:

$ readlink nonexistent
$ readlink hardlink
$ readlink -v nonexistent
readlink: nonexistent: No such file or directory
$ readlink -v hardlink
readlink: hardlink: Invalid argument

This way, we see the exact reason for a failure with readlink.

===== Превратить симлинк в команду в консоли =====

Можно пройти далее и положить этот симлинк в файл с бинарниками, которые учитывает система.

	* Если нужно, чтобы симлинк был доступен для всех пользователей в системе, его надо положить в „''/usr/local/bin/''” (или даже в „''/usr/bin''”, но туда лучше не лезть).
	* Если нужно, чтобы симлинк был доступен только для действующего пользователя, его надо положить в „''~/.local/bin/''”.

После этого в консоли (находясь в любом каталоге) можно набрать эту уникальную команду „''updeb''” и нажать Enter — так, словно в консоли была вызвана обычная линуксовая команда.

	Собственно, я только что сделал новую команду в Linux, и за это мне полагается большая круглая медаль «За передовую технологическую магию».

Перед тем как создавать «новую крутую короткую команду», рекомендуется проверить, нет ли аналогичной команды в системе:

''man debup''

Если появится справочная страница — перепродумать название своего нового симлинка. Выход из справки по клавише „q”,

===== Положить линк на скрипт в «Меню приложений» =====

Не надо все скрипты пихать в приложения, ведь их место в консоли. Но если очень хочется, то можно.

''mcedit ~/.local/share/applications/ИмяФайла.desktop''

Отредактировать „ИмяФайла.desktop”:

''[Desktop Entry]''
''Encoding=UTF-8''
''Name= Название новой программы''
''Comment= Если нужно''
''Type=Application''
''Terminal=true''
''Exec=~/.local/bin/МойСимЛинк''
''StartupNotify=true''
''Categories=System;''

Новая иконка появится в Меню приложений > Система.

Если надо сделать «новое приложение» доступным для всех пользователей в системе, файл „ИмяФайла.desktop” надо через „''sudo''” положить в  каталог „''/usr/share/applications/''”.
